<?xml version="1.0" encoding="iso-8859-1" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">

  <xs:include schemaLocation="common.xsd" />

  <!-- Script name starts with letter, . is allowed, this is different from MD scripts etc. -->
  <xs:simpleType name="aiscriptname">
    <xs:restriction base="xs:string">
      <xs:pattern value="[!A-Za-z][A-Za-z0-9_.]+" />
    </xs:restriction>
  </xs:simpleType>

  <!-- ===== Text simple types ==== -->

  <xs:simpleType name="labelname">
    <xs:annotation>
      <xs:documentation>
        Label name
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="namestring" />
  </xs:simpleType>

  <xs:simpleType name="interrupt_conditionsref">
    <xs:annotation>
      <xs:documentation>
        Name of a library interrupt condition set
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="namestring" />
  </xs:simpleType>

  <xs:simpleType name="interrupt_handlerref">
    <xs:annotation>
      <xs:documentation>
        Name of a library interrupt handler
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="namestring" />
  </xs:simpleType>

  <!-- ===== Enumeration simple types ==== -->

  <xs:simpleType name="fbehaviourlookup">
    <xs:annotation>
      <xs:documentation>
        Flight behaviour
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="flightbehaviour.default" />
          <xs:enumeration value="flightbehaviour.none" />
          <xs:enumeration value="flightbehaviour.gaindistance" />
          <xs:enumeration value="flightbehaviour.generic" />
          <xs:enumeration value="flightbehaviour.guidedmissile" />
          <xs:enumeration value="flightbehaviour.swarmmissile" />
          <xs:enumeration value="flightbehaviour.attackrun" />
          <xs:enumeration value="flightbehaviour.playerdronedefault" />
          <xs:enumeration value="flightbehaviour.playermissiledrone" />
          <xs:enumeration value="flightbehaviour.playershielddrone" />
          <xs:enumeration value="flightbehaviour.dogfight1" />
          <xs:enumeration value="flightbehaviour.dogfight2" />
          <xs:enumeration value="flightbehaviour.bigfight" />
          <xs:enumeration value="flightbehaviour.evasive_loop" />
          <xs:enumeration value="flightbehaviour.evasive_simple" />
          <xs:enumeration value="flightbehaviour.evasive_random" />
          <xs:enumeration value="flightbehaviour.evasive_roll" />
          <xs:enumeration value="flightbehaviour.evasive_spiral" />
          <xs:enumeration value="flightbehaviour.swarmdrone" />
          <xs:enumeration value="flightbehaviour.chase" />
          <xs:enumeration value="flightbehaviour.hardbrake" />
          <xs:enumeration value="flightbehaviour.crazyivan" />
          <xs:enumeration value="flightbehaviour.spiral" />
          <xs:enumeration value="flightbehaviour.halfloop" />
          <xs:enumeration value="flightbehaviour.loop" />
          <xs:enumeration value="flightbehaviour.dock" />
          <xs:enumeration value="flightbehaviour.pickupdrone" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="fcmlookup">
    <xs:annotation>
      <xs:documentation>
        Flight control model
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="flightcontrolmodel.forced" />
          <xs:enumeration value="flightcontrolmodel.highway" />
          <xs:enumeration value="flightcontrolmodel.linear" />
          <xs:enumeration value="flightcontrolmodel.spline" />
          <xs:enumeration value="flightcontrolmodel.steering" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="commandlookup">
    <xs:annotation>
      <xs:documentation>
        Command
      </xs:documentation>
    </xs:annotation>
    <xs:union memberTypes="expression">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="command.attackenemies">
            <xs:annotation>
              <xs:documentation>
                Attack Enemies Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.attackobject">
            <xs:annotation>
              <xs:documentation>
                Attack Object Command (param = the target to attack)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.buildexpansion">
            <xs:annotation>
              <xs:documentation>
                Build Expansion Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.buildship">
            <xs:annotation>
              <xs:documentation>
                Build Ship Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.buildstation">
            <xs:annotation>
              <xs:documentation>
                Build Station Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.buildupgrades">
            <xs:annotation>
              <xs:documentation>
                Build Upgrades Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.collect">
            <xs:annotation>
              <xs:documentation>
                Collect Command (param = the object to collect)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.freemining">
            <xs:annotation>
              <xs:documentation>
                Free Mining Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.freetrade">
            <xs:annotation>
              <xs:documentation>
                Free Trading Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.follow">
            <xs:annotation>
              <xs:documentation>
                Follow Command (param = the object to follow)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.escort">
            <xs:annotation>
              <xs:documentation>
                Escort Command (param = the object to escort)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.mining">
            <xs:annotation>
              <xs:documentation>
                Mining Command (param = the zone where stuff is mined)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.move">
            <xs:annotation>
              <xs:documentation>
                Move Command (param = the object/zone to fly to)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.patrol">
            <xs:annotation>
              <xs:documentation>
                Patrol Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.police">
            <xs:annotation>
              <xs:documentation>
                Police Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.protect">
            <xs:annotation>
              <xs:documentation>
                Protect Command (param = the object to protect)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.repair">
            <xs:annotation>
              <xs:documentation>
                Repair Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.scan">
            <xs:annotation>
              <xs:documentation>
                Scan Object Command (no param)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.support">
            <xs:annotation>
              <xs:documentation>
                Support Command (param = the object to support)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="command.trade">
            <xs:annotation>
              <xs:documentation>
                Trade Command (param = the object to trade with)
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <!-- ===== Attribute groups ==== -->

  <xs:attributeGroup name="blockingaction">
    <xs:attributeGroup ref="action" />
    <xs:attribute name="sinceversion" type="xs:nonNegativeInteger">
      <xs:annotation>
        <xs:documentation>
          Script version in which this blocking action was added
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <!-- ===== Complex Types ===== -->

  <xs:complexType name="run_script_param">
    <xs:annotation>
      <xs:documentation>
        AI script parameter
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="paramname" use="required">
      <xs:annotation>
        <xs:documentation>
          Parameter name
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="expression" use="required">
      <xs:annotation>
        <xs:documentation>
          Parameter value
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <!-- ===== Conditions ==== -->

  <!--
  <xs:group name="specificconditions_event">
    <xs:choice>

      <xs:element name="event_...">
      </xs:element>

    </xs:choice>
  </xs:group>
  -->

  <!--
  XML restriction: Elements with the same name and in the same scope must have the same type.
  Which means that check_all / check_any always have to behave the same, even if we know whether
  they are allowed to have event conditions or not. So we always allow them.
  -->

  <xs:group name="conditions_single_nonevent">
    <xs:choice>
      <xs:group ref="commonconditions_nonevent"/>
      <!-- There are no AI-specific non-event conditions -->
    </xs:choice>
  </xs:group>

  <xs:group name="conditions_single_event">
    <xs:choice>
      <xs:group ref="commonconditions_event"/>
      <!-- There are no AI-specific event conditions (yet) -->
      <!-- <xs:group ref="specificconditions_event"/> -->
    </xs:choice>
  </xs:group>

  <xs:group name="conditions">
    <xs:sequence>
      <xs:group ref="conditions_single_event" minOccurs="0" maxOccurs="1"/>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="check_all" type="checkall"/>
        <xs:element name="check_any" type="checkany"/>
        <xs:group ref="conditions_single_nonevent"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:complexType name="checkall">
    <xs:annotation>
      <xs:documentation>
        List of conditions all of which must be met
      </xs:documentation>
    </xs:annotation>
    <xs:group ref="conditions"/>
    <xs:attributeGroup ref="condition" />
    <xs:attributeGroup ref="counting" />
    <xs:attribute name="negate" type="negatecondition" />
  </xs:complexType>

  <xs:complexType name="checkany">
    <xs:annotation>
      <xs:documentation>
        List of conditions any one of which must be met
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice minOccurs="1" maxOccurs="unbounded">
        <xs:element name="check_all" type="checkall"/>
        <xs:element name="check_any" type="checkany"/>
        <xs:group ref="conditions_single_event"/>
        <xs:group ref="conditions_single_nonevent"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="condition" />
    <xs:attributeGroup ref="counting" />
    <xs:attribute name="negate" type="negatecondition" />
  </xs:complexType>

  <xs:group name="blockingaction">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="on_attentionchange">
          <xs:annotation>
            <xs:documentation>
              Actions to be performed on an attention level change. Blocking actions are not allowed.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:group ref="actions" />
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="interrupt_after_time">
          <xs:complexType>
            <xs:attribute name="time" type="expression" use="required">
              <xs:annotation>
                <xs:documentation>
                  Time duration until timeout
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="interrupt">
          <xs:annotation>
            <xs:documentation>
              Conditionally interrupt a blocking action and perform certain actions when the interrupt occurs.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="conditions" type="interrupt_conditions_withref" />
              <xs:element name="actions" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                  <xs:documentation>
                    Actions to be performed on an interrupt. Blocking actions are not allowed.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:group ref="actions" />
                  <xs:attribute name="comment" type="comment" />
                </xs:complexType>
              </xs:element>
            </xs:sequence>
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <!-- ===== Actions ==== -->

  <xs:group name="specificactions">
    <xs:choice>

      <xs:element name="add_ware_reservation">
        <xs:annotation>
          <xs:documentation>
            Reserve space for selling ware to an object.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="container" use="required">
            <xs:annotation>
              <xs:documentation>
                The container where the entity wants to reserve space for an amount of ware.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="entity" type="entity" use="required">
            <xs:annotation>
              <xs:documentation>
                Who to reserve this amount for.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attribute name="amount" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Positive number of units to reserve.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="duration" type="expression">
            <xs:annotation>
              <xs:documentation>
                Duration of this reservation (optional, defaults to 1 hour)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="replace" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Whether amount should be added to any existing reservation or replace it. (optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename">
            <xs:annotation>
              <xs:documentation>
                The amount that is now reserved for this entity. Can be different from amount if there already was a reservation. (optional)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="remove_ware_reservation">
        <xs:annotation>
          <xs:documentation>
            Remove a space reservation that was previously added with &lt;add_ware_reservation&gt; (fails silently if there was no matching reservation)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="container" use="required">
            <xs:annotation>
              <xs:documentation>
                The container from which to remove the reservation.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="entity" type="entity">
            <xs:annotation>
              <xs:documentation>
                Whose reservation to remove (optional, all reservations for ware (if specified) will be removed if omitted!)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="ware">
            <xs:annotation>
              <xs:documentation>
                What reservations to remove (optional, all reservations for entity (if specified) will be removed if omitted!)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                How many units from the reservation to remove (optional, will remove all units if omitted, only has an effect if entity and ware are specified!)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="dock_masstraffic_drone">
        <xs:annotation>
          <xs:documentation>
            Dock a masstraffic drone. Any picked up objects will be transferred to the cargostorage of destination (if possible). (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="destination" type="object" use="required">
            <xs:annotation>
              <xs:documentation>
                Destination the drone should dock at. This object must have masstraffic docks defined! (Large+ ships or stations)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="immediate" type="boolean">
            <xs:annotation>
              <xs:documentation>
                If docking process should happen immediately, the drone will be teleported to destination(optional, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="execute_custom_trade">
        <xs:annotation>
          <xs:documentation>
            Execute trade procedure, this will create the necessary trade and cause cargo to be transferred from seller to buyer (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction"/>
          <xs:attribute name="buyer" type="buyer" use="required" />
          <xs:attribute name="seller" type="seller" use="required" />
          <xs:attribute name="amount" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Amount of goods to transfer
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ware" type="ware" use="required" />
          <xs:attribute name="totalprice" type="expression">
            <xs:annotation>
              <xs:documentation>
                Total price of goods in this trade (defaults to 0! takes precedence over price)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="price" type="expression">
            <xs:annotation>
              <xs:documentation>
                Price per unit in this trade (defaults to 0! ignored if totalprice is set)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="unbundle" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the ware be unbundled on transfer? (turn ware into ammo for the recipient, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tradeorder" type="expression">
            <xs:annotation>
              <xs:documentation>
                Trade order to be removed from shopping list, in case this action is aborted. Accessed by &lt;save_ai_action_state&gt;.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="execute_trade">
        <xs:annotation>
          <xs:documentation>
            Execute trade procedure, this will cause cargo to be transferred (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction"/>
          <xs:attribute name="tradeoffer" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The trade offer (buy or sell) that is to be acted upon
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tradepartner" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The object that wants to do the trade (if a ship wants to use a trade offer on a station, that station is the owner and the ship is the tradepartner)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="amount" type="expression">
            <xs:annotation>
              <xs:documentation>
                Amount of goods to transfer, can not exceed amount in offer (0=default=all in offer)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="unbundle" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Should the ware be unbundled on transfer? (turn ware into ammo for the recipient, defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="move_approach_path">
        <xs:annotation>
          <xs:documentation>
            Move along a dynamic path that will lead to the dronedock (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="abortpath" type="booleanexpression" />
          <xs:attribute name="finishonapproach" type="boolean" />
          <xs:attribute name="destination" type="expression">
            <xs:annotation>
              <xs:documentation>
                Destination object (will be derived from dronedock if omitted)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="dronedock" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The DroneLaunchPad that should be used for docking
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="flightbehaviour" type="fbehaviourlookup" />
          <xs:attribute name="relativemovement" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the object should fly in the coordinate space of the defined object as opposed to its parent component (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="forcesteering" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If this is true the ship will fly on steering flight control model (while in high attention), this is also implictely true if relativemovemt is true or the ship is flying in a formation (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="move_docking">
        <xs:annotation>
          <xs:documentation>
            Move to dock (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="abortpath" type="booleanexpression" />
          <xs:attribute name="dock" type="expression">
            <xs:annotation>
              <xs:documentation>
                Docking bay component slot (find using &lt;find_dock_location&gt;)
                Only dock or dronedock can be used, if both are specified, dock will be used!
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="dronedock" type="expression">
            <xs:annotation>
              <xs:documentation>
                DroneLaunchPad component
                Only dock or dronedock can be used, if both are specified, dock will be used!
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="forcesteering" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If this is true the ship will fly on steering flight control model (while in high attention), this is also implictely true if the ship is flying in a formation (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="move_undocking">
        <xs:annotation>
          <xs:documentation>
            Move to undock (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="finishonapproach" type="boolean" />          
          <xs:attribute name="dock" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Docking bay component slot
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="forceposition" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the object has to be in the exact given position at the end of the path (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="forcesteering" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If this is true the ship will fly on steering flight control model (while in high attention), this is also implictely true if the ship is flying in a formation (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="move_gate">
        <xs:annotation>
          <xs:documentation>
            Move through a Jump Gate, after the transition the ship will move out of the way of the gate (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="abortpath" type="booleanexpression" />
          <xs:attribute name="finishonapproach" type="boolean" />
          <xs:attribute name="gate" type="expression">
            <xs:annotation>
              <xs:documentation>
                Jump Gate to go through
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="forcesteering" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If this is true the ship will fly on steering flight control model (while in high attention), this is also implictely true if the ship is flying in a formation (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>      

      <xs:element name="move_navmesh">
        <xs:annotation>
          <xs:documentation>
            Move to destination via navmesh (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="abortpath" type="booleanexpression" />
          <xs:attribute name="finishonapproach" type="boolean" />
          <xs:attribute name="usemasstrafficlane" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If object is originates from mass traffic, plot a navmesh path that follows the original traffic lane
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="destination" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                The object that has the navmesh to fly over
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="flightbehaviour" type="fbehaviourlookup" />
          <xs:attribute name="avoid" type="booleanexpression" />
          <xs:attribute name="relativemovement" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the object should fly in the coordinate space of the defined object as opposed to its parent component (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="forcesteering" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If this is true the ship will fly on steering flight control model (while in high attention), this is also implictely true if relativemovemt is true or the ship is flying in a formation (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="move_strafe">
        <xs:annotation>
          <xs:documentation>
            Move to destination by strafing (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="abortpath" type="booleanexpression" />
          <xs:attribute name="finishonapproach" type="boolean" />
          <xs:attribute name="destination" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Destination object
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="flightbehaviour" type="fbehaviourlookup" />
          <xs:attribute name="avoid" type="booleanexpression" />
          <xs:attribute name="forcerotation" type="booleanexpression" />
          <xs:attribute name="relativemovement" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the object should fly in the coordinate space of the defined object as opposed to its parent component (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="forcesteering" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If this is true the ship will fly on steering flight control model (while in high attention), this is also implictely true if relativemovemt is true or the ship is flying in a formation (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="move_target_points">
        <xs:annotation>
          <xs:documentation>
            Move to destination (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="nextposition" type="position" minOccurs="0" maxOccurs="1" >
              <xs:annotation>
                <xs:documentation>
                  Next position to look at for the last target point.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="abortpath" type="booleanexpression" />
          <xs:attribute name="finishonapproach" type="boolean" />
          <xs:attribute name="destination" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Destination object (macro of this object will be used for target point lookup!)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tags" type="expression">
            <xs:annotation>
              <xs:documentation>
                Either a single tag or a list of tags which are required for the target points
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reverse" type="booleanexpression" >
            <xs:annotation>
              <xs:documentation>
                Whether the object should fly to the target points in reverse order
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="flightbehaviour" type="fbehaviourlookup" />
          <xs:attribute name="relativemovement" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the object should fly in the coordinate space of the defined object as opposed to its parent component (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="forcesteering" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If this is true the ship will fly on steering flight control model (while in high attention), this is also implictely true if relativemovemt is true or the ship is flying in a formation (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="move_to">
        <xs:annotation>
          <xs:documentation>
            Move to destination (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="abortpath" type="booleanexpression" />
          <xs:attribute name="finishonapproach" type="boolean" />
          <xs:attribute name="usehighways" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether highways should be used, skips global pathing if set to false (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="destination" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Destination object or space
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="flightbehaviour" type="fbehaviourlookup" />
          <xs:attribute name="avoid" type="booleanexpression" />
          <xs:attribute name="forcerotation" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the object should keep rotating to match the defined orientation at the end of the path (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="forceposition" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the object has to be in the exact given position at the end of the path (defaults to true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="relativemovement" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Whether the object should fly in the coordinate space of the defined object as opposed to its parent component (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="forcesteering" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If this is true the ship will fly on steering flight control model (while in high attention), this is also implictely true if relativemovemt is true or the ship is flying in a formation (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reverse" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                Let the ship fly in reverse (defaults to false)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="jump">
        <xs:annotation>
          <xs:documentation>
            Jump object to different location (blocking, using jumpdrive)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="position" type="position" minOccurs="0" maxOccurs="1" />
            <xs:element name="rotation" type="rotation" minOccurs="0" maxOccurs="1" />
            <xs:element name="safepos" type="safepos" minOccurs="0" maxOccurs="1" >
              <xs:annotation>
                <xs:documentation>
                  Jump to safe position (takes precedence over position node!)
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="orientation" type="orientation" minOccurs="0" maxOccurs="1" >
              <xs:annotation>
                <xs:documentation>
                  Orientation in relation to refpos or refobject (takes precedence over rotation node!)
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:group ref="blockingaction" />
          </xs:choice>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="zone" type="zone" use="required" />
          <xs:attribute name="skipcharge" type="booleanexpression" >
            <xs:annotation>
              <xs:documentation>
                Skip jumpdrive charging and jump directly
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="ignorefuel" type="booleanexpression" >
            <xs:annotation>
              <xs:documentation>
                Ignore fuel requirements for jump
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" />
        </xs:complexType>
      </xs:element>

      <xs:element name="abort_jump">
        <xs:annotation>
          <xs:documentation>
            Abort any active jump procedures
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

        <xs:element name="resume">
        <xs:annotation>
          <xs:documentation>
            Resume at specified label
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="label" type="labelname" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="return">
        <xs:annotation>
          <xs:documentation>
            Return to caller
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="retval" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Named return value
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="name" type="paramname" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Return value name
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value" type="expression" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Return value
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="comment" type="comment" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="value" type="expression">
            <xs:annotation>
              <xs:documentation>
                Unnamed return value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
        <xs:key name="return_value">
          <xs:selector xpath="retval" />
          <xs:field xpath="@name" />
        </xs:key>
      </xs:element>

      <xs:element name="return_to_masstraffic">
        <xs:annotation>
          <xs:documentation>
            Instruct object to re-join the mass traffic, only works for ships that came from mass traffic in the first place!
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="detach_from_masstraffic">
        <xs:annotation>
          <xs:documentation>
            (blocking) Instruct object to detach from mass traffic, e.g. after executing a trade order - OK to call for ships that don't use mass traffic as well
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="blockingaction" />
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="wait" type="boolean" />
        </xs:complexType>
      </xs:element>

      <xs:element name="run_script">
        <xs:annotation>
          <xs:documentation>
            Run script (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="param" type="run_script_param" minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="save_retval" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Save named return value in a variable
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="name" type="paramname" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Return value name
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="variable" type="lvaluename" use="required" />
                <xs:attribute name="comment" type="comment" />
              </xs:complexType>
            </xs:element>
            <!-- No blockingaction elements here -->
            <!-- <xs:group ref="blockingaction" /> -->
            <xs:element name="on_attentionchange" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
                  Actions to be performed when called script returns, in case the attention level changed in the meantime. Blocking actions are not allowed.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:group ref="actions" />
                <xs:attribute name="comment" type="comment" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="name" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Script name
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="result" type="lvaluename" />
        </xs:complexType>
        <xs:key name="run_script_param_name">
          <xs:selector xpath="param" />
          <xs:field xpath="@name" />
        </xs:key>
        <xs:key name="run_script_save_retval_name">
          <xs:selector xpath="save_retval" />
          <xs:field xpath="@name" />
        </xs:key>
      </xs:element>

      <xs:element name="run_interrupt_script">
        <xs:annotation>
          <xs:documentation>
            Run a script on a global interrupt. The script will be executed on top of the current call-stack if its interrupt priority is high enough.
            No further interrupt actions will run after this action. This action is only allowed in interrupt actions.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="param" type="run_script_param" minOccurs="0" maxOccurs="unbounded" />
          </xs:sequence>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="name" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Script name (must be a constant string expression)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="abortscripts" type="booleanexpression">
            <xs:annotation>
              <xs:documentation>
                If true then the scripts called by this script will be aborted before the interrupt script is started.
                If false (default) then the interrupt script will be started on top of the callstack.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="resume" type="labelname">
            <xs:annotation>
              <xs:documentation>
                Label to resume at when the interrupt script returns. By default the script will resume at the current label.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
        <xs:key name="run_interrupt_script_param_name">
          <xs:selector xpath="param" />
          <xs:field xpath="@name" />
        </xs:key>
      </xs:element>

      <xs:element name="abort_called_scripts">
        <xs:annotation>
          <xs:documentation>
            Abort scripts that were called by this script on a global interrupt. No further interrupt actions will run after this action
            and this script will resume at the current label. This action is only allowed in interrupt actions.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="resume" type="labelname">
            <xs:annotation>
              <xs:documentation>
                Label to resume at after the interrupt. By default the script will resume at the current label.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="wait_for_prev_script">
        <xs:annotation>
          <xs:documentation>
            Wait for blocking action of previous AI script to complete (blocking).
            Requires information stored on this object via &lt;save_ai_action_state&gt;. Only a few specific blocking actions are handled here, in other cases no blocking happens.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="blockingaction" />
          </xs:sequence>
          <xs:attributeGroup ref="blockingaction" />
          <xs:attribute name="action" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Value that receives the name of the blocking action of the previous script
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="object" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Value that receives the event source object of the blocking action of the previous script
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="param" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Value that receives the first parameter of the blocking action of the previous script (depends on the action).
                For &lt;execute_custom_trade&gt; this is the buyer.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="param2" type="lvalueexpression">
            <xs:annotation>
              <xs:documentation>
                Value that receives the second parameter of the blocking action of the previous script (depends on the action).
                For &lt;execute_custom_trade&gt; this is the trade order.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="select_flight_behaviour">
        <xs:annotation>
          <xs:documentation>
            Randomly select an appropriate flight behaviour for the given entity
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="entity" type="entity" use="required" />
          <xs:attribute name="evasive" type="boolean" use="required" />
          <xs:attribute name="result" type="lvaluename" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_command">
        <xs:annotation>
          <xs:documentation>
            Sets the current command for the script's entity. The command data will remain valid until either it's overwritten or this script ends. It becomes valid again automatically when a called script returns.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="command" type="commandlookup" use="required" />
          <xs:attribute name="param" type="expression">
            <xs:annotation>
              <xs:documentation>
                Primary command parameter (meaning depends on command)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="param2" type="expression">
            <xs:annotation>
              <xs:documentation>
                Secondary command parameter (meaning depends on command)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="set_flight_behaviour">
        <xs:annotation>
          <xs:documentation>
            Sets the default flight behaviour for this unit (can still be overridden per move_to order)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="flightbehaviour" type="fbehaviourlookup" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_flight_control_model">
        <xs:annotation>
          <xs:documentation>
            Overrides this unit's default flight control model
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="flightcontrolmodel" type="fcmlookup" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_to_default_flight_control_model">
        <xs:annotation>
          <xs:documentation>
            Resets the unit to use the default flight control model
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="set_avoid_collisions">
        <xs:annotation>
          <xs:documentation>
            Enables/disabled collision avoidance for this object
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="enabled" type="boolean" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="shoot">
        <xs:annotation>
          <xs:documentation>
            Start shooting a weapon
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="slot" type="controlslottag" use="required" />
          <xs:attribute name="weapontype" type="weapontypelookup">
            <xs:annotation>
              <xs:documentation>
                Turret types to use for shooting at the target(s), defaults to combat.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="shoot_at">
        <xs:annotation>
          <xs:documentation>
            Shoot at target when the opportunity arises
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="attacker" use="required" />
          <xs:attribute name="slot" type="controlslottag" use="required" />
          <xs:attribute name="target" type="targetobject" use="required" />
          <xs:attribute name="additional_targets" type="expression" use="optional">
            <xs:annotation>
              <xs:documentation>
                Optional list of additional targets that may be fired upon if opportunity arises (not supported together with largetarget=true)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="tolerance" type="expression" use="required">
            <xs:annotation>
              <xs:documentation>
                Tolerance angle
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="locktarget" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Prevent target from being overridden? Default is false
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="largetarget" type="boolean">
            <xs:annotation>
              <xs:documentation>
                Is the target a very large object, e.g. a station? Default is false (does not support additonal targets)
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="weapontype" type="weapontypelookup">
            <xs:annotation>
              <xs:documentation>
                Turret types to use for shooting at the target(s), defaults to combat.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_moving">
        <xs:annotation>
          <xs:documentation>
            Stop moving
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="immediate" type="boolean" />
        </xs:complexType>
      </xs:element>

      <xs:element name="stop_shooting">
        <xs:annotation>
          <xs:documentation>
            Stop shooting
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attributeGroup ref="action" />
          <xs:attribute name="object" type="object" use="required" />
          <xs:attribute name="slot" type="controlslottag" use="required" />
        </xs:complexType>
      </xs:element>

      <xs:element name="wait">
        <xs:annotation>
          <xs:documentation>
            Wait (sleep) for specified time duration (blocking)
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="blockingaction" />
          <xs:attributeGroup ref="blockingaction" />
          <xs:attributeGroup ref="random" />
        </xs:complexType>
      </xs:element>

    </xs:choice>
  </xs:group>

  <xs:group name="actionchoice">
    <xs:choice>
      <xs:element name="do_all" type="doall"/>
      <xs:element name="do_any" type="doany"/>
      <xs:sequence>
        <xs:element name="do_if" type="doif" />
        <xs:element name="do_elseif" type="doelseif" minOccurs="0" maxOccurs="unbounded" />
        <xs:element name="do_else" type="doelse" minOccurs="0" maxOccurs="1" />
      </xs:sequence>
      <xs:element name="do_while" type="dowhile"/>
      <xs:group ref="commonactions"/>
      <xs:group ref="specificactions"/>
    </xs:choice>
  </xs:group>

  <xs:group name="actions">
    <xs:sequence>
      <xs:group ref="actionchoice" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:group>

  <xs:group name="actionswithlabel">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="actionchoice"/>

        <xs:element name="label">
          <xs:annotation>
            <xs:documentation>
              Label
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="labelname" use="required" />
          </xs:complexType>
        </xs:element>

      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:complexType name="actions">
    <xs:annotation>
      <xs:documentation>
        AI script actions
      </xs:documentation>
    </xs:annotation>
    <xs:group ref="actionswithlabel" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="doall">
    <xs:annotation>
      <xs:documentation>
        Actions in all sub-nodes will be performed.
      </xs:documentation>
    </xs:annotation>
    <xs:group ref="actions"/>
    <xs:attributeGroup ref="action"/>
    <xs:attributeGroup ref="counting"/>
  </xs:complexType>

  <xs:complexType name="doany">
    <xs:annotation>
      <xs:documentation>
        A randomly selected sub-node action will be performed. The chances of selection can be specified by using weights on the actions.
      </xs:documentation>
    </xs:annotation>
    <xs:group ref="actions"/>
    <xs:attributeGroup ref="action"/>
  </xs:complexType>

  <xs:complexType name="doif">
    <xs:annotation>
      <xs:documentation>
        Actions in sub-nodes will be performed only if the value matches.
        Can be followed by &lt;do_elseif&gt; and/or &lt;do_else&gt;.
      </xs:documentation>
    </xs:annotation>
    <xs:group ref="actions"/>
    <xs:attributeGroup ref="action"/>
    <xs:attributeGroup ref="conditionalaction"/>
  </xs:complexType>

  <xs:complexType name="doelseif">
    <xs:annotation>
      <xs:documentation>
        Actions in sub-nodes will be performed only if the conditions in the previous nodes are not met and if this action's values matches.
        Can be followed by &lt;do_elseif&gt; and/or &lt;do_else&gt;.
      </xs:documentation>
    </xs:annotation>
    <xs:group ref="actions"/>
    <xs:attributeGroup ref="action"/>
    <xs:attributeGroup ref="conditionalaction"/>
  </xs:complexType>

  <xs:complexType name="doelse">
    <xs:annotation>
      <xs:documentation>
        Actions in sub-nodes will be performed only if the conditions in the previous nodes are not met.
      </xs:documentation>
    </xs:annotation>
    <xs:group ref="actions"/>
    <xs:attributeGroup ref="action"/>
  </xs:complexType>

  <xs:complexType name="dowhile">
    <xs:annotation>
      <xs:documentation>
        Actions in sub-nodes will be performed in a loop while the value matches.
      </xs:documentation>
    </xs:annotation>
    <xs:group ref="actions"/>
    <xs:attributeGroup ref="action"/>
    <xs:attributeGroup ref="conditionalaction"/>
  </xs:complexType>

  <!-- ===== Interrupts ===== -->

  <!-- Interrupt conditions -->
  <xs:complexType name="interrupt_conditions">
    <xs:group ref="conditions" />
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="interrupt_conditions_withref">
    <xs:annotation>
      <xs:documentation>
        Conditions that must be met in order for the interrupt to occur.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="interrupt_conditions">
        <xs:attribute name="ref" type="interrupt_conditionsref" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- Interrupt handler -->
  <xs:complexType name="interrupt_handler">
    <xs:sequence>
      <xs:element name="conditions" type="interrupt_conditions_withref" minOccurs="0" maxOccurs="1" />
      <xs:element name="actions" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Actions to be performed on the global interrupt. Blocking actions are not allowed.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="actions" />
          <xs:attribute name="comment" type="comment" />
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="comment" type="comment" />
  </xs:complexType>

  <xs:complexType name="interrupt_handler_withref">
    <xs:annotation>
      <xs:documentation>
        Global interrupt handler for this AI script and any called scripts. Can reference a library interrupt handler.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="interrupt_handler">
        <xs:attribute name="ref" type="interrupt_handlerref" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interrupt_library">
    <xs:annotation>
      <xs:documentation>
        Library of named interrupts and interrupt conditions in global namespace
      </xs:documentation>
    </xs:annotation>
    <!-- Named conditions and named handlers -->
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="handler">
        <xs:annotation>
          <xs:documentation>
            Library definition of a global interrupt handler. Can be referenced by any AI script.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="interrupt_handler">
              <xs:attribute name="name" type="namestring" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Globally unique handler name
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="conditions">
        <xs:annotation>
          <xs:documentation>
            Library definition of conditions that must be met in order for an interrupt to occur. Can be referenced by interrupt handlers in any AI script.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="interrupt_conditions">
              <xs:attribute name="name" type="namestring" use="required">
                <xs:annotation>
                  <xs:documentation>
                    Globally unique condition set name
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="interrupts">
    <xs:annotation>
      <xs:documentation>
        Global interrupt handlers and library definitions
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="library" type="interrupt_library" minOccurs="0" maxOccurs="1" />
      <xs:element name="handler" type="interrupt_handler_withref" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <!-- ===== Root element ==== -->

  <xs:element name="aiscript">
    <xs:annotation>
      <xs:documentation>
        AI Script root element
      </xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name="documentation" type="filedoc" minOccurs="0" maxOccurs="1" />
        <xs:element name="params" minOccurs="0" maxOccurs="1">
          <xs:complexType>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
              <xs:element name="param">
                <xs:annotation>
                  <xs:documentation>
                    AI script parameter
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attribute name="name" type="paramname" use="required">
                    <xs:annotation>
                      <xs:documentation>
                        Parameter name
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="default" type="expression">
                    <xs:annotation>
                      <xs:documentation>
                        Default value (parameter is required if default value not supplied)
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="comment" type="comment" />
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
          <xs:key name="aiscript_param_name">
            <xs:selector xpath="param" />
            <xs:field xpath="@name" />
          </xs:key>
        </xs:element>
        <xs:element name="interrupts" type="interrupts" minOccurs="0" maxOccurs="1" />
        <xs:element name="init" minOccurs="0" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              Non-blocking AI script actions for initialization (will be performed right before the attention-specific actions)
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:group ref="actions" />
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="actions" type="actions" minOccurs="0" maxOccurs="1">
          <xs:key name="label_name">
            <xs:selector xpath="label" />
            <xs:field xpath="@name" />
          </xs:key>
          <xs:keyref name="resume_label" refer="label_name">
            <xs:selector xpath=".//resume" />
            <xs:field xpath="@label" />
          </xs:keyref>
        </xs:element>
        <xs:element name="attention" minOccurs="0" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>
              Actions for minimum attention level
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="actions" type="actions">
                <xs:key name="attention_label_name">
                  <xs:selector xpath="label" />
                  <xs:field xpath="@name" />
                </xs:key>
                <xs:keyref name="attention_resume_label" refer="attention_label_name">
                  <xs:selector xpath=".//resume" />
                  <xs:field xpath="@label" />
                </xs:keyref>
              </xs:element>
            </xs:sequence>
            <xs:attribute name="min" type="attentionlookup" use="required">
              <xs:annotation>
                <xs:documentation>
                  Minimum attention level
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="on_abort" minOccurs="0" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              Non-blocking AI script actions for cleanup, in case the script is aborted (will be performed right before the script is terminated).
              If the script is aborted as a result of the entity being killed, the event data of &lt;event_object_destroyed&gt; can be accessed.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:group ref="actions" />
            <xs:attribute name="killed" type="boolean">
              <xs:annotation>
                <xs:documentation>
                  Set to true if the actions should only be performed if the entity is killed.
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="comment" type="comment" />
          </xs:complexType>
        </xs:element>
        <xs:element name="signature" minOccurs="0" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              Signature
            </xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="name" type="aiscriptname" use="required" />
      <xs:attribute name="priority" type="xs:nonNegativeInteger">
        <xs:annotation>
          <xs:documentation>
            The interrupt priority. In order for this script to be triggered by a global interrupt handler, this priority must be higher than the previous interrupt priority (default is 0).
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="version" type="xs:nonNegativeInteger">
        <xs:annotation>
          <xs:documentation>
            Script version. The version has to be increased when new blocking actions are inserted.
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="comment" type="comment" />
    </xs:complexType>
    <xs:key name="attention">
      <xs:selector xpath="attention" />
      <xs:field xpath="@min" />
    </xs:key>
  </xs:element>

</xs:schema>
